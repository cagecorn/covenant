<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Covenant - 6v6 Auto Battle Simulation (v0.4 Advanced Logic)</title>
    <style>
        /* CSSëŠ” ì´ì „ ë²„ì „(v0.3)ê³¼ ë™ì¼í•©ë‹ˆë‹¤ */
        body{background-color:#2c3e50;color:white;font-family:sans-serif;display:flex;flex-direction:column;align-items:center;margin:0;padding:20px}h1{text-shadow:2px 2px 4px rgba(0,0,0,.5)}canvas{background-color:#34495e;border:3px solid #7f8c8d;border-radius:10px}#controls{margin-top:15px}button{padding:10px 20px;font-size:16px;border:none;border-radius:8px;cursor:pointer;background:#27ae60;color:white;transition:all .3s ease}button:hover{background:#2ecc71}#log{width:750px;height:100px;background:rgba(0,0,0,.3);border-radius:5px;margin-top:15px;padding:10px;overflow-y:scroll;font-size:14px;border:1px solid #7f8c8d;line-height:1.5}
    </style>
</head>
<body>

    <h1>Covenant - 6vs6 ìë™ ì „íˆ¬ ì‹œë®¬ë ˆì´ì…˜ (v0.4 ê°œì„ ëœ ë¡œì§)</h1>
    <canvas id="gameCanvas" width="750" height="500"></canvas>
    <div id="controls">
        <button id="startBtn">ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘</button>
    </div>
    <div id="log"></div>

<script>
// =======================================================================
// 1. ê¸°ë³¸ ì„¤ì • (v0.3ê³¼ ìœ ì‚¬)
// =======================================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const logElement = document.getElementById('log');

const GRID_COLS = 15;
const GRID_ROWS = 10;
const CELL_SIZE = 50;

const backgroundCanvas = document.createElement('canvas');
backgroundCanvas.width = canvas.width;
backgroundCanvas.height = canvas.height;
const backgroundCtx = backgroundCanvas.getContext('2d');


// =======================================================================
// 2. ê²Œì„ ë°ì´í„° êµ¬ì¡° ì •ì˜
// =======================================================================

// [ì¶”ê°€ ìµœì í™”] ë°ì´í„° ì¤‘ì‹¬ ì„¤ê³„: ìœ ë‹› í…œí”Œë¦¿
const UNIT_TEMPLATES = {
    player_warrior: { name: 'ê°•í•œ ì „ì‚¬', classType: 'Warrior', hp: 100, attackPower: 20, valor: 20, weight: 50, skills: ['powerStrike', 'stoneSkin'] },
    player_knight:  { name: 'ë°©ì–´í˜• ê¸°ì‚¬', classType: 'Cavalry', hp: 120, attackPower: 15, valor: 30, weight: 60, skills: ['stoneSkin'] },
    player_archer:  { name: 'ëª…ì‚¬ìˆ˜', classType: 'Archer',  hp: 60, attackPower: 25, valor: 5, weight: 30, skills: ['powerStrike'] },
    player_healer:  { name: 'ì¹˜ìœ ì‚¬', classType: 'Healer',  hp: 70, attackPower: 10, valor: 15, weight: 25, skills: ['heal'] },

    enemy_orc_chief: { name: 'ì˜¤í¬ ëŒ€ì¥', classType: 'Warrior', hp: 110, attackPower: 22, valor: 20, weight: 55, skills: ['powerStrike'] },
    enemy_shaman:    { name: 'ì˜¤í¬ ì£¼ìˆ ì‚¬', classType: 'Mage', hp: 60, attackPower: 28, valor: 15, weight: 38, skills: ['heal'] },
    enemy_goblin:    { name: 'ê³ ë¸”ë¦° ì •ì°°ë³‘', classType: 'Archer', hp: 50, attackPower: 20, valor: 5, weight: 20 },
    enemy_troll:     { name: 'íŠ¸ë¡¤', classType: 'Warrior', hp: 150, attackPower: 18, valor: 10, weight: 80, skills: ['stoneSkin'] },
};

const SKILLS = {
    powerStrike: { name: 'íŒŒì›Œ ìŠ¤íŠ¸ë¼ì´í¬', type: 'active', probability: 0.4,
        effect: (caster, target) => {
            const damage = Math.floor(caster.getAttackPower() * 1.5);
            logMessage(`ğŸ’¥ ${caster.name}(ì´)ê°€ ìŠ¤í‚¬ [${SKILLS.powerStrike.name}](ìœ¼)ë¡œ ${target.name}ì—ê²Œ ${damage}ì˜ ê°•ë ¥í•œ í”¼í•´!`);
            target.takeDamage(damage);
        }
    },
    heal: { name: 'ì¹˜ìœ ', type: 'active', probability: 0.5,
        effect: (caster) => {
            const healAmount = Math.floor(caster.maxHp * 0.3);
            caster.hp = Math.min(caster.maxHp, caster.hp + healAmount);
            logMessage(`ğŸ’– ${caster.name}(ì´)ê°€ ìŠ¤í‚¬ [${SKILLS.heal.name}](ìœ¼)ë¡œ ì²´ë ¥ì„ ${healAmount} íšŒë³µ!`);
        }
    },
    stoneSkin: { name: 'ìŠ¤í†¤ ìŠ¤í‚¨', type: 'passive',
        effect: (caster) => {
            const defenseBonus = Math.floor(caster.valor * 0.5);
            caster.shield += defenseBonus;
            caster.maxShield += defenseBonus;
            logMessage(`ğŸ›¡ï¸ ${caster.name}(ì´)ê°€ íŒ¨ì‹œë¸Œ [${SKILLS.stoneSkin.name}] íš¨ê³¼ë¡œ ë³´í˜¸ë§‰ì´ ${defenseBonus} ì¦ê°€!`);
        }
    },
     berserk: { name: 'ë²„ì„œì»¤ ëª¨ë“œ', type: 'passive',
        effect: (caster) => {
            // [ì¶”ê°€ ìµœì í™”] ìŠ¤íƒ¯ì„ ì§ì ‘ ë°”ê¾¸ëŠ” ëŒ€ì‹  ë³´ë„ˆìŠ¤ ê°’ìœ¼ë¡œ ì €ì¥
            caster.bonusAttack += 10;
            logMessage(`ğŸ”¥ ${caster.name}(ì´)ê°€ íŒ¨ì‹œë¸Œ [${SKILLS.berserk.name}] íš¨ê³¼ë¡œ ê³µê²©ë ¥ì´ 10 ì¦ê°€!`);
        }
    }
};

const CLASS_STATS = {
    Warrior:  { range: 1, moveSpeed: 3, icon: 'âš”ï¸' }, Archer:   { range: 4, moveSpeed: 3, icon: 'ğŸ¹' },
    Cavalry:  { range: 2, moveSpeed: 5, icon: 'ğŸ' }, Mage:     { range: 3, moveSpeed: 2, icon: 'ğŸ”®' },
    Healer:   { range: 3, moveSpeed: 2, icon: 'ğŸ’–' }
};

let unitCounter = 0;

class Unit {
    constructor(template, team, x, y) {
        Object.assign(this, template); // í…œí”Œë¦¿ì˜ ëª¨ë“  ì†ì„±ì„ ë³µì‚¬
        this.id = unitCounter++;
        this.team = team;
        this.x = x;
        this.y = y;
        this.maxHp = this.hp;
        this.skills = template.skills || [];

        const stats = CLASS_STATS[this.classType];
        Object.assign(this, stats);
        
        this.isDead = false;
        this.hasActed = false;
        this.shield = this.valor * 2;
        this.maxShield = this.shield;

        // [ì¶”ê°€ ìµœì í™”] ê³„ì‚°ëœ ìŠ¤íƒ¯ì„ ì €ì¥í•  ì†ì„±
        this.bonusAttack = 0;
    }

    applyPassiveSkills() {
        this.skills.forEach(skillKey => {
            const skill = SKILLS[skillKey];
            if (skill && skill.type === 'passive') {
                skill.effect(this);
            }
        });
    }

    // [ì¶”ê°€ ìµœì í™”] ìµœì¢… ê³µê²©ë ¥ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜
    getAttackPower() {
        const valorBonus = (this.shield / this.maxShield) * 0.5;
        // ê¸°ë³¸ê³µê²©ë ¥ + íŒ¨ì‹œë¸Œ ë³´ë„ˆìŠ¤ + ìš©ë§¹ ë³´ë„ˆìŠ¤
        return Math.floor((this.attackPower + this.bonusAttack) * (1 + valorBonus));
    }

    takeDamage(damage) {
        if (this.shield > 0) {
            const shieldDamage = Math.min(this.shield, damage);
            this.shield -= shieldDamage;
            damage -= shieldDamage;
        }
        if (damage > 0) this.hp -= damage;
        if (this.hp <= 0) {
            this.hp = 0;
            this.isDead = true;
            logMessage(`${this.team === 'player' ? 'ì•„êµ°' : 'ì '} ${this.name}(ì´)ê°€ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤!`);
        }
    }
    
    // [ë¡œì§ ìˆ˜ì •] "ì´ë™ í›„ í–‰ë™" AI
    takeTurn(enemies) {
        if (this.isDead || this.hasActed) return;
        
        // --- 1. ì´ë™ ë‹¨ê³„ ---
        const closestEnemy = this.findClosestEnemy(enemies);
        if (closestEnemy) {
            this.moveTowards(closestEnemy);
        }

        // --- 2. í–‰ë™(ìŠ¤í‚¬/ê³µê²©) ë‹¨ê³„ ---
        // ì´ë™ í›„, ë‹¤ì‹œ ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨
        const target = this.findClosestEnemy(enemies);
        if (target && this.isInRange(target)) {
            let didUseSkill = false;
            // ì•¡í‹°ë¸Œ ìŠ¤í‚¬ ì‚¬ìš© ì‹œë„
            for (const skillKey of this.skills) {
                const skill = SKILLS[skillKey];
                if (skill && skill.type === 'active' && Math.random() < skill.probability) {
                    if (skill.name === 'ì¹˜ìœ ') {
                        // íì€ ìì‹ ì—ê²Œë§Œ ì‚¬ìš© (ì²´ë ¥ì´ 70% ë¯¸ë§Œì¼ ë•Œ)
                        if (this.hp < this.maxHp * 0.7) {
                           skill.effect(this);
                           didUseSkill = true;
                        }
                    } else {
                        skill.effect(this, target);
                        didUseSkill = true;
                    }
                    if(didUseSkill) break;
                }
            }
            // ìŠ¤í‚¬ì„ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ì¼ë°˜ ê³µê²©
            if (!didUseSkill) {
                this.attack(target);
            }
        } else {
            logMessage(`${this.name}(ì´)ê°€ ì£¼ë³€ì— ê³µê²©í•  ëŒ€ìƒì´ ì—†ì–´ ëŒ€ê¸°í•©ë‹ˆë‹¤.`);
        }
        
        this.hasActed = true;
    }
    
    findClosestEnemy(enemies) {
        if (!enemies || enemies.length === 0) return null;
        return enemies.reduce((closest, current) => {
            const closestDist = Math.abs(this.x - closest.x) + Math.abs(this.y - closest.y);
            const currentDist = Math.abs(this.x - current.x) + Math.abs(this.y - current.y);
            return currentDist < closestDist ? current : closest;
        });
    }

    isInRange(target) {
        return (Math.abs(this.x - target.x) + Math.abs(this.y - target.y)) <= this.range;
    }

    attack(target) {
        const finalAttackPower = this.getAttackPower();
        logMessage(`âš”ï¸ ${this.name}(ì´)ê°€ ${target.name}ì—ê²Œ ì¼ë°˜ ê³µê²©! (${finalAttackPower} í”¼í•´)`);
        target.takeDamage(finalAttackPower);
    }

    moveTowards(target) {
        let bestX = this.x;
        let bestY = this.y;
        let minDistance = Math.abs(this.x - target.x) + Math.abs(this.y - target.y);

        // ì´ë™ ê°€ëŠ¥í•œ ëª¨ë“  ìœ„ì¹˜ë¥¼ íƒìƒ‰í•˜ì—¬ ê°€ì¥ ì¢‹ì€ ì§€ì ì„ ì°¾ìŒ
        for (let i = 0; i <= this.moveSpeed; i++) {
            for (let j = 0; j <= this.moveSpeed - i; j++) {
                const checkPositions = [
                    {x: this.x + i, y: this.y + j}, {x: this.x - i, y: this.y + j},
                    {x: this.x + i, y: this.y - j}, {x: this.x - i, y: this.y - j}
                ];
                for(const pos of checkPositions){
                    // ë§µ ê²½ê³„ ì²´í¬
                    if(pos.x < 0 || pos.x >= GRID_COLS || pos.y < 0 || pos.y >= GRID_ROWS) continue;

                    const dist = Math.abs(pos.x - target.x) + Math.abs(pos.y - target.y);
                    if(dist < minDistance){
                        minDistance = dist;
                        bestX = pos.x;
                        bestY = pos.y;
                    }
                }
            }
        }
        
        if (this.x !== bestX || this.y !== bestY) {
            logMessage(`â¡ï¸ ${this.name}(ì´)ê°€ (${this.x},${this.y})ì—ì„œ (${bestX},${bestY})ë¡œ ì´ë™.`);
            this.x = bestX;
            this.y = bestY;
        }
    }
}

// =======================================================================
// 3. ë Œë”ë§ (v0.3ê³¼ ë™ì¼)
// =======================================================================
function preRenderGrid(){backgroundCtx.strokeStyle="#7f8c8d",backgroundCtx.lineWidth=1;for(let t=0;t<=GRID_COLS;t++)backgroundCtx.beginPath(),backgroundCtx.moveTo(t*CELL_SIZE,0),backgroundCtx.lineTo(t*CELL_SIZE,GRID_ROWS*CELL_SIZE),backgroundCtx.stroke();for(let t=0;t<=GRID_ROWS;t++)backgroundCtx.beginPath(),backgroundCtx.moveTo(0,t*CELL_SIZE),backgroundCtx.lineTo(GRID_COLS*CELL_SIZE,t*CELL_SIZE),backgroundCtx.stroke()}function drawUnits(t){t.forEach(t=>{if(t.isDead)return;const e=t.x*CELL_SIZE+CELL_SIZE/2,i=t.y*CELL_SIZE+CELL_SIZE/2;ctx.font="24px sans-serif",ctx.textAlign="center",ctx.textBaseline="middle",ctx.fillText(t.icon,e,i),ctx.fillStyle="player"===t.team?"blue":"red",ctx.beginPath(),ctx.arc(e,i+15,5,0,2*Math.PI),ctx.fill();const s= .8*CELL_SIZE,a=t.hp/t.maxHp;if(ctx.fillStyle="#555",ctx.fillRect(e-s/2,i-20,s,5),ctx.fillStyle="green",ctx.fillRect(e-s/2,i-20,s*a,5),t.maxShield>0){const a=t.shield/t.maxShield;ctx.fillStyle="#555",ctx.fillRect(e-s/2,i-26,s,5),ctx.fillStyle="cyan",ctx.fillRect(e-s/2,i-26,s*a,5)}})}function render(t){ctx.clearRect(0,0,canvas.width,canvas.height),ctx.drawImage(backgroundCanvas,0,0),drawUnits(t)}

// =======================================================================
// 4 & 5. ì „íˆ¬ ë¡œì§ ë° ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
// =======================================================================
let playerUnits=[],enemyUnits=[],allUnits=[],isSimulationRunning=!1,logBuffer=[];function init(){unitCounter=0,playerUnits=[new Unit(UNIT_TEMPLATES.player_warrior,"player",1,2),new Unit(UNIT_TEMPLATES.player_knight,"player",1,5),new Unit(UNIT_TEMPLATES.player_archer,"player",0,3),new Unit(UNIT_TEMPLATES.player_healer,"player",0,6)],enemyUnits=[new Unit(UNIT_TEMPLATES.enemy_orc_chief,"enemy",13,2),new Unit(UNIT_TEMPLATES.enemy_shaman,"enemy",14,5),new Unit(UNIT_TEMPLATES.enemy_goblin,"enemy",14,3),new Unit(UNIT_TEMPLATES.enemy_troll,"enemy",13,7)],allUnits=[...playerUnits,...enemyUnits],logMessage("--- ì „íˆ¬ ì‹œì‘! íŒ¨ì‹œë¸Œ ìŠ¤í‚¬ ë°œë™ ---"),allUnits.forEach(t=>t.applyPassiveSkills()),flushLog(),logElement.innerHTML="",logMessage("ì „íˆ¬ ì¤€ë¹„ ì™„ë£Œ. ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”."),flushLog();let t=function(){render(allUnits),isSimulationRunning&&requestAnimationFrame(t)};requestAnimationFrame(t)}async function runTurn(){logMessage("--- ìƒˆë¡œìš´ í„´ ì‹œì‘ ---");const t=allUnits.filter(t=>!t.isDead).sort((t,e)=>t.weight-e.weight);t.forEach(t=>t.hasActed=!1);for(const e of t){if(e.isDead)continue;const t="player"===e.team?enemyUnits.filter(t=>!t.isDead):playerUnits.filter(t=>!t.isDead);e.takeTurn(t),await sleep(400)}if(flushLog(),0===playerUnits.filter(t=>!t.isDead).length)return logMessage("í”Œë ˆì´ì–´ íŒ€ íŒ¨ë°°!"),isSimulationRunning=!1,startBtn.disabled=!1,void flushLog();if(0===enemyUnits.filter(t=>!t.isDead).length)return logMessage("í”Œë ˆì´ì–´ íŒ€ ìŠ¹ë¦¬!"),isSimulationRunning=!1,startBtn.disabled=!1,void flushLog();isSimulationRunning&&setTimeout(runTurn,1e3)}function sleep(t){return new Promise(e=>setTimeout(e,t))}function logMessage(t){logBuffer.push(t)}function flushLog(){logBuffer.length>0&&(logElement.innerHTML+=logBuffer.join("<br>"),logElement.scrollTop=logElement.scrollHeight,logBuffer=[])}startBtn.addEventListener("click",()=>{isSimulationRunning||(isSimulationRunning=!0,startBtn.disabled=!0,init(),runTurn())}),window.onload=()=>{preRenderGrid(),init(),render(allUnits)};
</script>
</body>
</html>
