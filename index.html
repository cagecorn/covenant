<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Covenant - 6v6 Auto Battle Simulation (v0.1)</title>
    <style>
        body {
            background-color: #2c3e50;
            color: white;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        h1 {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        canvas {
            background-color: #34495e;
            border: 3px solid #7f8c8d;
            border-radius: 10px;
        }
        #controls {
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #27ae60;
            color: white;
            transition: all 0.3s ease;
        }
        button:hover {
            background: #2ecc71;
        }
        #log {
            width: 750px;
            height: 100px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-top: 15px;
            padding: 10px;
            overflow-y: scroll;
            font-size: 14px;
            border: 1px solid #7f8c8d;
        }
    </style>
</head>
<body>

    <h1>Covenant - 6vs6 ìë™ ì „íˆ¬ ì‹œë®¬ë ˆì´ì…˜</h1>
    <canvas id="gameCanvas" width="750" height="500"></canvas>
    <div id="controls">
        <button id="startBtn">ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘</button>
    </div>
    <div id="log"></div>

<script>
// =======================================================================
// 1ë‹¨ê³„: ê¸°ë³¸ ì„¤ì • ë° Canvas ì¤€ë¹„
// =======================================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const logElement = document.getElementById('log');

const GRID_COLS = 15;
const GRID_ROWS = 10;
const CELL_SIZE = 50;

// =======================================================================
// 2ë‹¨ê³„: ê²Œì„ ë°ì´í„° êµ¬ì¡° ì •ì˜ (README.md ê¸°ë°˜)
// =======================================================================

/**
 * README.mdì˜ ìš©ë³‘ í´ë˜ìŠ¤ë³„ ê¸°ë³¸ ìŠ¤íƒ¯ ì •ì˜
 * ì „ì‚¬: ì‚¬ê±°ë¦¬ 1, ì´ë™ë ¥ 3
 * ê¶ìˆ˜: ì‚¬ê±°ë¦¬ 4, ì´ë™ë ¥ 3
 * ê¸°ë³‘: ì‚¬ê±°ë¦¬ 2, ì´ë™ë ¥ 5
 * ë§ˆë²•ì‚¬: ì‚¬ê±°ë¦¬ 3, ì´ë™ë ¥ 2
 * íëŸ¬: ì‚¬ê±°ë¦¬ 3, ì´ë™ë ¥ 2 (ì´ë²ˆ ë²„ì „ì—ì„œëŠ” ê³µê²© ìœ ë‹›ìœ¼ë¡œ ê°„ì£¼)
 */
const CLASS_STATS = {
    Warrior:  { range: 1, moveSpeed: 3, icon: 'âš”ï¸' },
    Archer:   { range: 4, moveSpeed: 3, icon: 'ğŸ¹' },
    Cavalry:  { range: 2, moveSpeed: 5, icon: 'ğŸ' },
    Mage:     { range: 3, moveSpeed: 2, icon: 'ğŸ”®' },
    Healer:   { range: 3, moveSpeed: 2, icon: 'ğŸ’–' } // í ê¸°ëŠ¥ì€ ì¶”í›„ êµ¬í˜„
};

let unitCounter = 0;

// ìš©ë³‘(ìœ ë‹›)ì˜ ì„¤ê³„ë„(Class) ì •ì˜
class Unit {
    constructor(config) {
        this.id = unitCounter++;
        this.name = config.name;
        this.team = config.team; // 'player' or 'enemy'
        this.classType = config.classType;

        // ìœ„ì¹˜ ì •ë³´ (ê·¸ë¦¬ë“œ ì¢Œí‘œ)
        this.x = config.x;
        this.y = config.y;

        // ê¸°ë³¸ ìŠ¤íƒ¯
        this.hp = config.hp;
        this.maxHp = config.hp;
        this.attackPower = config.attackPower;

        // README.mdì˜ í•µì‹¬ ì‹œìŠ¤í…œ: [ìš©ë§¹]ê³¼ [ë¬´ê²Œ]
        this.valor = config.valor;   // [ìš©ë§¹] ìŠ¤íƒ¯
        this.weight = config.weight; // [ë¬´ê²Œ] ìŠ¤íƒ¯

        // í´ë˜ìŠ¤ ê¸°ë°˜ ìŠ¤íƒ¯ (ì‚¬ê±°ë¦¬, ì´ë™ë ¥)
        const stats = CLASS_STATS[this.classType];
        this.range = stats.range;
        this.moveSpeed = stats.moveSpeed;
        this.icon = stats.icon;
        
        // ì „íˆ¬ ì¤‘ ìƒíƒœ
        this.isDead = false;
        this.hasActed = false;

        // [ìš©ë§¹] ìŠ¤íƒ¯ì— ë”°ë¥¸ ë³´í˜¸ë§‰ ìƒì„±
        this.shield = this.valor * 2; // ìš©ë§¹ 1ë‹¹ ë³´í˜¸ë§‰ 2ë¡œ ê°€ì •
        this.maxShield = this.shield;
    }

    // ë°ë¯¸ì§€ë¥¼ ë°›ëŠ” ë¡œì§
    takeDamage(damage) {
        // ë³´í˜¸ë§‰ì´ ë¨¼ì € í”¼í•´ë¥¼ í¡ìˆ˜
        if (this.shield > 0) {
            const shieldDamage = Math.min(this.shield, damage);
            this.shield -= shieldDamage;
            damage -= shieldDamage;
        }

        // ë‚¨ì€ í”¼í•´ê°€ ìˆë‹¤ë©´ ì²´ë ¥ ê°ì†Œ
        if (damage > 0) {
            this.hp -= damage;
        }

        if (this.hp <= 0) {
            this.hp = 0;
            this.isDead = true;
            logMessage(`${this.name}(ì´)ê°€ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤!`, 'death');
        }
    }

    // ìì‹ ì˜ í„´ì— í–‰ë™ì„ ê²°ì •í•˜ëŠ” AI
    takeTurn(allUnits) {
        if (this.isDead || this.hasActed) return;

        // 1. ëª©í‘œ ì„¤ì •: ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ì°¾ëŠ”ë‹¤.
        const enemies = allUnits.filter(u => u.team !== this.team && !u.isDead);
        if (enemies.length === 0) {
            this.hasActed = true;
            return; // ì‹¸ìš¸ ì ì´ ì—†ìŒ
        }

        let closestEnemy = null;
        let minDistance = Infinity;

        enemies.forEach(enemy => {
            const distance = Math.abs(this.x - enemy.x) + Math.abs(this.y - enemy.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestEnemy = enemy;
            }
        });

        // 2. í–‰ë™ ê²°ì •: ê³µê²© ë˜ëŠ” ì´ë™
        // ì‚¬ê±°ë¦¬ ë‚´ì— ì ì´ ìˆëŠ”ê°€?
        if (minDistance <= this.range) {
            // ê³µê²©
            this.attack(closestEnemy);
        } else {
            // ì´ë™
            this.moveTowards(closestEnemy, allUnits);
        }

        this.hasActed = true;
    }

    // ê³µê²© ë¡œì§
    attack(target) {
        // [ìš©ë§¹] ì‹œìŠ¤í…œ: ë³´í˜¸ë§‰ ìˆ˜ì¹˜ì— ë¹„ë¡€í•´ ê³µê²©ë ¥ ì¦ê°€ (ìµœëŒ€ 50% ë³´ë„ˆìŠ¤)
        const valorBonus = (this.shield / this.maxShield) * 0.5;
        const finalAttackPower = Math.floor(this.attackPower * (1 + valorBonus));

        logMessage(
            `${this.name}(ì´)ê°€ ${target.name}ì„(ë¥¼) ê³µê²©! (í”¼í•´: ${finalAttackPower})`,
            'attack'
        );
        target.takeDamage(finalAttackPower);
    }

    // ì´ë™ ë¡œì§
    moveTowards(target, allUnits) {
        let movedDistance = 0;
        let currentX = this.x;
        let currentY = this.y;

        while (movedDistance < this.moveSpeed) {
            const dx = target.x - currentX;
            const dy = target.y - currentY;

            if (dx === 0 && dy === 0) break;

            let nextX = currentX;
            let nextY = currentY;

            // Xì¶•, Yì¶• ì¤‘ ë” ë¨¼ ìª½ìœ¼ë¡œ ë¨¼ì € í•œ ì¹¸ ì´ë™
            if (Math.abs(dx) > Math.abs(dy)) {
                nextX += Math.sign(dx);
            } else {
                nextY += Math.sign(dy);
            }

            // í•´ë‹¹ ìœ„ì¹˜ë¡œ ì´ë™ ê°€ëŠ¥í•œì§€ í™•ì¸ (ë‹¤ë¥¸ ìœ ë‹›ì´ ì—†ëŠ”ê°€?)
            const isOccupied = allUnits.some(u => !u.isDead && u.x === nextX && u.y === nextY);

            if (!isOccupied) {
                currentX = nextX;
                currentY = nextY;
                movedDistance++;
            } else {
                // ê¸¸ì´ ë§‰í˜”ìœ¼ë©´ ì´ë™ ì¤‘ì§€
                break;
            }
        }
        
        if (this.x !== currentX || this.y !== currentY) {
            logMessage(`${this.name}(ì´)ê°€ (${this.x},${this.y})ì—ì„œ (${currentX},${currentY})ë¡œ ì´ë™.`, 'move');
            this.x = currentX;
            this.y = currentY;
        }
    }
}


// =======================================================================
// 3ë‹¨ê³„: ì‹œê°ì  í‘œí˜„ (ë Œë”ë§)
// =======================================================================

function drawGrid() {
    ctx.strokeStyle = '#7f8c8d';
    for (let i = 0; i <= GRID_COLS; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, GRID_ROWS * CELL_SIZE);
        ctx.stroke();
    }
    for (let i = 0; i <= GRID_ROWS; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(GRID_COLS * CELL_SIZE, i * CELL_SIZE);
        ctx.stroke();
    }
}

function drawUnits(units) {
    units.forEach(unit => {
        if (unit.isDead) return;

        const x = unit.x * CELL_SIZE + CELL_SIZE / 2;
        const y = unit.y * CELL_SIZE + CELL_SIZE / 2;

        // ìœ ë‹› ì•„ì´ì½˜ ê·¸ë¦¬ê¸°
        ctx.font = '24px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(unit.icon, x, y);

        // íŒ€ ìƒ‰ìƒ í‘œì‹œ (í•˜ë‹¨ ì›)
        ctx.fillStyle = unit.team === 'player' ? 'blue' : 'red';
        ctx.beginPath();
        ctx.arc(x, y + 15, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // ì²´ë ¥ ë°”
        const hpBarWidth = CELL_SIZE * 0.8;
        const hpRatio = unit.hp / unit.maxHp;
        ctx.fillStyle = '#555';
        ctx.fillRect(x - hpBarWidth / 2, y - 20, hpBarWidth, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(x - hpBarWidth / 2, y - 20, hpBarWidth * hpRatio, 5);

        // ë³´í˜¸ë§‰ ë°”
        if (unit.maxShield > 0) {
            const shieldRatio = unit.shield / unit.maxShield;
            ctx.fillStyle = '#555';
            ctx.fillRect(x - hpBarWidth / 2, y - 26, hpBarWidth, 5);
            ctx.fillStyle = 'cyan';
            ctx.fillRect(x - hpBarWidth / 2, y - 26, hpBarWidth * shieldRatio, 5);
        }
    });
}

// í™”ë©´ì„ ë‹¤ì‹œ ê·¸ë¦¬ëŠ” ë©”ì¸ ë Œë”ë§ ë£¨í”„
function render(units) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();
    drawUnits(units);
}

// =======================================================================
// 4ë‹¨ê³„ & 5ë‹¨ê³„: ì „íˆ¬ ë¡œì§ ë° ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
// =======================================================================

let allUnits = [];
let isSimulationRunning = false;

// ê²Œì„ ì´ˆê¸°í™” í•¨ìˆ˜
function init() {
    unitCounter = 0;
    allUnits = [
        // Player Team (6ëª…)
        new Unit({ name: 'í”Œë ˆì´ì–´ ì „ì‚¬1', team: 'player', classType: 'Warrior', x: 1, y: 2, hp: 100, attackPower: 20, valor: 20, weight: 50 }),
        new Unit({ name: 'í”Œë ˆì´ì–´ ì „ì‚¬2', team: 'player', classType: 'Warrior', x: 1, y: 7, hp: 100, attackPower: 20, valor: 10, weight: 60 }),
        new Unit({ name: 'í”Œë ˆì´ì–´ ê¶ìˆ˜1', team: 'player', classType: 'Archer',  x: 0, y: 3, hp: 60, attackPower: 25, valor: 5, weight: 30 }),
        new Unit({ name: 'í”Œë ˆì´ì–´ ê¶ìˆ˜2', team: 'player', classType: 'Archer',  x: 0, y: 6, hp: 60, attackPower: 25, valor: 15, weight: 25 }),
        new Unit({ name: 'í”Œë ˆì´ì–´ ê¸°ë³‘', team: 'player', classType: 'Cavalry', x: 1, y: 5, hp: 80, attackPower: 18, valor: 30, weight: 40 }),
        new Unit({ name: 'í”Œë ˆì´ì–´ ë§ˆë²•ì‚¬', team: 'player', classType: 'Mage',    x: 0, y: 5, hp: 50, attackPower: 30, valor: 25, weight: 35 }),

        // Enemy Team (6ëª…)
        new Unit({ name: 'ì  ì „ì‚¬1', team: 'enemy', classType: 'Warrior', x: 13, y: 2, hp: 100, attackPower: 20, valor: 20, weight: 55 }),
        new Unit({ name: 'ì  ì „ì‚¬2', team: 'enemy', classType: 'Warrior', x: 13, y: 7, hp: 100, attackPower: 20, valor: 15, weight: 58 }),
        new Unit({ name: 'ì  ê¶ìˆ˜1', team: 'enemy', classType: 'Archer',  x: 14, y: 3, hp: 60, attackPower: 25, valor: 10, weight: 32 }),
        new Unit({ name: 'ì  ê¶ìˆ˜2', team: 'enemy', classType: 'Archer',  x: 14, y: 6, hp: 60, attackPower: 25, valor: 10, weight: 28 }),
        new Unit({ name: 'ì  ê¸°ë³‘', team: 'enemy', classType: 'Cavalry', x: 13, y: 5, hp: 80, attackPower: 18, valor: 25, weight: 45 }),
        new Unit({ name: 'ì  ë§ˆë²•ì‚¬', team: 'enemy', classType: 'Mage',    x: 14, y: 5, hp: 50, attackPower: 30, valor: 20, weight: 38 }),
    ];
    logElement.innerHTML = '';
    logMessage('ì „íˆ¬ ì¤€ë¹„ ì™„ë£Œ. ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.', 'info');
    render(allUnits);
}

// ì‹œë®¬ë ˆì´ì…˜ì˜ í•œ í„´ì„ ì§„í–‰í•˜ëŠ” í•¨ìˆ˜
async function runTurn() {
    logMessage('--- ìƒˆë¡œìš´ í„´ ì‹œì‘ ---', 'turn');
    
    // 1. í–‰ë™ ìˆœì„œ ê²°ì •: [ë¬´ê²Œ]ê°€ ë‚®ì„ìˆ˜ë¡ ë¨¼ì € í–‰ë™
    const turnOrder = allUnits
        .filter(u => !u.isDead)
        .sort((a, b) => a.weight - b.weight);

    // ëª¨ë“  ìœ ë‹›ì˜ 'í–‰ë™ ì™„ë£Œ' ìƒíƒœ ì´ˆê¸°í™”
    turnOrder.forEach(u => u.hasActed = false);

    // 2. ìˆœì„œëŒ€ë¡œ í–‰ë™ ê°œì‹œ
    for (const unit of turnOrder) {
        if (unit.isDead) continue;
        
        unit.takeTurn(allUnits);
        render(allUnits); // ê° ìœ ë‹› í–‰ë™ í›„ í™”ë©´ ê°±ì‹ 
        await sleep(300); // í–‰ë™ì„ ì‹œê°ì ìœ¼ë¡œ í™•ì¸í•˜ê¸° ìœ„í•œ ì§€ì—°
    }

    // 3. í„´ ì¢…ë£Œ ë° ê²Œì„ ì˜¤ë²„ í™•ì¸
    const livingPlayers = allUnits.filter(u => u.team === 'player' && !u.isDead).length;
    const livingEnemies = allUnits.filter(u => u.team === 'enemy' && !u.isDead).length;

    if (livingPlayers === 0) {
        logMessage('í”Œë ˆì´ì–´ íŒ€ íŒ¨ë°°!', 'game-over');
        isSimulationRunning = false;
        startBtn.disabled = false;
        return;
    }
    if (livingEnemies === 0) {
        logMessage('í”Œë ˆì´ì–´ íŒ€ ìŠ¹ë¦¬!', 'game-over');
        isSimulationRunning = false;
        startBtn.disabled = false;
        return;
    }

    // ê²Œì„ì´ ëë‚˜ì§€ ì•Šì•˜ìœ¼ë©´ ë‹¤ìŒ í„´ ì§„í–‰
    if (isSimulationRunning) {
        setTimeout(runTurn, 1000); // 1ì´ˆ í›„ ë‹¤ìŒ í„´ ì‹œì‘
    }
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function logMessage(message, type) {
    logElement.innerHTML += `<div class="${type}">${message}</div>`;
    logElement.scrollTop = logElement.scrollHeight; // í•­ìƒ ìµœì‹  ë¡œê·¸ê°€ ë³´ì´ë„ë¡ ìŠ¤í¬ë¡¤
}

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
startBtn.addEventListener('click', () => {
    if (isSimulationRunning) return;
    isSimulationRunning = true;
    startBtn.disabled = true;
    init(); // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
    runTurn(); // ì²« í„´ ì‹œì‘
});

// í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
window.onload = init;
</script>
</body>
</html>
