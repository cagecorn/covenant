<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Covenant - 6v6 Auto Battle Simulation (v0.2 Optimized)</title>
    <style>
        body {
            background-color: #2c3e50;
            color: white;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        h1 {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        canvas {
            background-color: #34495e;
            border: 3px solid #7f8c8d;
            border-radius: 10px;
        }
        #controls {
            margin-top: 15px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #27ae60;
            color: white;
            transition: all 0.3s ease;
        }
        button:hover {
            background: #2ecc71;
        }
        #log {
            width: 750px;
            height: 100px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-top: 15px;
            padding: 10px;
            overflow-y: scroll;
            font-size: 14px;
            border: 1px solid #7f8c8d;
            line-height: 1.5;
        }
    </style>
</head>
<body>

    <h1>Covenant - 6vs6 ìë™ ì „íˆ¬ ì‹œë®¬ë ˆì´ì…˜ (ìµœì í™” ë²„ì „)</h1>
    <canvas id="gameCanvas" width="750" height="500"></canvas>
    <div id="controls">
        <button id="startBtn">ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘</button>
    </div>
    <div id="log"></div>

<script>
// =======================================================================
// 1. ê¸°ë³¸ ì„¤ì • ë° Canvas ì¤€ë¹„
// =======================================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const logElement = document.getElementById('log');

const GRID_COLS = 15;
const GRID_ROWS = 10;
const CELL_SIZE = 50;

// [ìµœì í™” 1] ì˜¤í”„ìŠ¤í¬ë¦° ìº”ë²„ìŠ¤ (Off-screen Canvas) ë„ì…
// ë°°ê²½ ê·¸ë¦¬ë“œëŠ” í•œ ë²ˆë§Œ ê·¸ë ¤ë‘ê³ , ë§¤ í”„ë ˆì„ë§ˆë‹¤ ë³µì‚¬í•´ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.
const backgroundCanvas = document.createElement('canvas');
backgroundCanvas.width = canvas.width;
backgroundCanvas.height = canvas.height;
const backgroundCtx = backgroundCanvas.getContext('2d');


// =======================================================================
// 2. ê²Œì„ ë°ì´í„° êµ¬ì¡° ì •ì˜ (README.md ê¸°ë°˜)
// =======================================================================
const CLASS_STATS = {
    Warrior:  { range: 1, moveSpeed: 3, icon: 'âš”ï¸' },
    Archer:   { range: 4, moveSpeed: 3, icon: 'ğŸ¹' },
    Cavalry:  { range: 2, moveSpeed: 5, icon: 'ğŸ' },
    Mage:     { range: 3, moveSpeed: 2, icon: 'ğŸ”®' },
    Healer:   { range: 3, moveSpeed: 2, icon: 'ğŸ’–' }
};

let unitCounter = 0;

class Unit {
    constructor(config) {
        this.id = unitCounter++;
        this.name = config.name;
        this.team = config.team;
        this.classType = config.classType;
        this.x = config.x;
        this.y = config.y;
        this.hp = config.hp;
        this.maxHp = config.hp;
        this.attackPower = config.attackPower;
        this.valor = config.valor;
        this.weight = config.weight;

        const stats = CLASS_STATS[this.classType];
        this.range = stats.range;
        this.moveSpeed = stats.moveSpeed;
        this.icon = stats.icon;
        
        this.isDead = false;
        this.hasActed = false;

        this.shield = this.valor * 2;
        this.maxShield = this.shield;
    }

    takeDamage(damage) {
        if (this.shield > 0) {
            const shieldDamage = Math.min(this.shield, damage);
            this.shield -= shieldDamage;
            damage -= shieldDamage;
        }
        if (damage > 0) {
            this.hp -= damage;
        }
        if (this.hp <= 0) {
            this.hp = 0;
            this.isDead = true;
            logMessage(`${this.team === 'player' ? 'ì•„êµ°' : 'ì '} ${this.name}(ì´)ê°€ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤!`);
        }
    }

    // [ìµœì í™” 2] AI ê°œì„  - íƒìƒ‰ ëŒ€ìƒì„ ë¯¸ë¦¬ ì „ë‹¬ë°›ì•„ ê³„ì‚°ëŸ‰ ê°ì†Œ
    takeTurn(enemies) {
        if (this.isDead || this.hasActed) return;

        if (enemies.length === 0) {
            this.hasActed = true;
            return;
        }

        let closestEnemy = null;
        let minDistance = Infinity;

        enemies.forEach(enemy => {
            const distance = Math.abs(this.x - enemy.x) + Math.abs(this.y - enemy.y);
            if (distance < minDistance) {
                minDistance = distance;
                closestEnemy = enemy;
            }
        });

        if (minDistance <= this.range) {
            this.attack(closestEnemy);
        } else {
            this.moveTowards(closestEnemy);
        }
        this.hasActed = true;
    }

    attack(target) {
        const valorBonus = (this.shield / this.maxShield) * 0.5;
        const finalAttackPower = Math.floor(this.attackPower * (1 + valorBonus));
        logMessage(`${this.name}(ì´)ê°€ ${target.name}ì—ê²Œ ${finalAttackPower} í”¼í•´ë¥¼ ì…í˜”ìŠµë‹ˆë‹¤.`);
        target.takeDamage(finalAttackPower);
    }

    // [ìµœì í™” 2] AI ê°œì„  - ì „ì²´ ìœ ë‹› ë°°ì—´ì„ íƒìƒ‰í•  í•„ìš” ì—†ìŒ
    moveTowards(target) {
        let movedDistance = 0;
        let newX = this.x;
        let newY = this.y;

        // ì´ë™ ë¡œì§ì€ ê¸°ì¡´ê³¼ ìœ ì‚¬í•˜ë‚˜, ì¶©ëŒ ê²€ì‚¬ëŠ” í„´ ê´€ë¦¬ìì—ì„œ ì²˜ë¦¬
        // (ì´ë²ˆ ë²„ì „ì—ì„œëŠ” ì¶©ëŒ ê²€ì‚¬ë¥¼ ìƒëµí•˜ì—¬ AI ì´ë™ ë¡œì§ì— ì§‘ì¤‘)
        const dx = Math.sign(target.x - this.x);
        const dy = Math.sign(target.y - this.y);

        // moveSpeed ë§Œí¼ ìµœëŒ€í•œ ì´ë™
        for(let i = 0; i < this.moveSpeed; i++) {
             if (Math.abs(target.x - newX) > Math.abs(target.y - newY)) {
                newX += dx;
            } else if (target.y !== newY) {
                newY += dy;
            } else if (target.x !== newX) {
                 newX += dx;
            } else {
                 break; // ëª©í‘œì— ë„ì°©
            }
        }
        
        logMessage(`${this.name}(ì´)ê°€ (${this.x},${this.y})ì—ì„œ (${newX},${newY})ë¡œ ì´ë™.`);
        this.x = newX;
        this.y = newY;
    }
}

// =======================================================================
// 3. ì‹œê°ì  í‘œí˜„ (ë Œë”ë§)
// =======================================================================

// [ìµœì í™” 1] ê·¸ë¦¬ë“œë¥¼ ë¯¸ë¦¬ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
function preRenderGrid() {
    backgroundCtx.strokeStyle = '#7f8c8d';
    backgroundCtx.lineWidth = 1;
    for (let i = 0; i <= GRID_COLS; i++) {
        backgroundCtx.beginPath();
        backgroundCtx.moveTo(i * CELL_SIZE, 0);
        backgroundCtx.lineTo(i * CELL_SIZE, GRID_ROWS * CELL_SIZE);
        backgroundCtx.stroke();
    }
    for (let i = 0; i <= GRID_ROWS; i++) {
        backgroundCtx.beginPath();
        backgroundCtx.moveTo(0, i * CELL_SIZE);
        backgroundCtx.lineTo(GRID_COLS * CELL_SIZE, i * CELL_SIZE);
        backgroundCtx.stroke();
    }
}

function drawUnits(units) {
    units.forEach(unit => {
        if (unit.isDead) return;

        const x = unit.x * CELL_SIZE + CELL_SIZE / 2;
        const y = unit.y * CELL_SIZE + CELL_SIZE / 2;

        ctx.font = '24px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(unit.icon, x, y);

        ctx.fillStyle = unit.team === 'player' ? 'blue' : 'red';
        ctx.beginPath();
        ctx.arc(x, y + 15, 5, 0, Math.PI * 2);
        ctx.fill();
        
        const hpBarWidth = CELL_SIZE * 0.8;
        const hpRatio = unit.hp / unit.maxHp;
        ctx.fillStyle = '#555';
        ctx.fillRect(x - hpBarWidth / 2, y - 20, hpBarWidth, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(x - hpBarWidth / 2, y - 20, hpBarWidth * hpRatio, 5);

        if (unit.maxShield > 0) {
            const shieldRatio = unit.shield / unit.maxShield;
            ctx.fillStyle = '#555';
            ctx.fillRect(x - hpBarWidth / 2, y - 26, hpBarWidth, 5);
            ctx.fillStyle = 'cyan';
            ctx.fillRect(x - hpBarWidth / 2, y - 26, hpBarWidth * shieldRatio, 5);
        }
    });
}

// [ìµœì í™” 1] ë©”ì¸ ë Œë”ë§ ë£¨í”„ ê°œì„ 
function render(units) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // ë¯¸ë¦¬ ê·¸ë ¤ë‘” ë°°ê²½ì„ ë³µì‚¬
    ctx.drawImage(backgroundCanvas, 0, 0);
    // ë™ì ì¸ ìœ ë‹›ë“¤ë§Œ ê·¸ë¦¬ê¸°
    drawUnits(units);
}

// =======================================================================
// 4 & 5. ì „íˆ¬ ë¡œì§ ë° ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰
// =======================================================================

// [ìµœì í™” 3] ë°ì´í„° ê´€ë¦¬ ê°œì„  - íŒ€ë³„ë¡œ ìœ ë‹› ë°°ì—´ ë¶„ë¦¬
let playerUnits = [];
let enemyUnits = [];
let allUnits = [];
let isSimulationRunning = false;
// [ìµœì í™” 4] ë¡œê·¸ ë²„í¼ë§
let logBuffer = [];


function init() {
    unitCounter = 0;
    playerUnits = [
        new Unit({ name: 'ì „ì‚¬1', team: 'player', classType: 'Warrior', x: 1, y: 2, hp: 100, attackPower: 20, valor: 20, weight: 50 }),
        new Unit({ name: 'ì „ì‚¬2', team: 'player', classType: 'Warrior', x: 1, y: 7, hp: 100, attackPower: 20, valor: 10, weight: 60 }),
        new Unit({ name: 'ê¶ìˆ˜1', team: 'player', classType: 'Archer',  x: 0, y: 3, hp: 60, attackPower: 25, valor: 5, weight: 30 }),
        new Unit({ name: 'ê¶ìˆ˜2', team: 'player', classType: 'Archer',  x: 0, y: 6, hp: 60, attackPower: 25, valor: 15, weight: 25 }),
        new Unit({ name: 'ê¸°ë³‘', team: 'player', classType: 'Cavalry', x: 1, y: 5, hp: 80, attackPower: 18, valor: 30, weight: 40 }),
        new Unit({ name: 'ë§ˆë²•ì‚¬', team: 'player', classType: 'Mage',    x: 0, y: 5, hp: 50, attackPower: 30, valor: 25, weight: 35 }),
    ];
    enemyUnits = [
        new Unit({ name: 'ì˜¤í¬1', team: 'enemy', classType: 'Warrior', x: 13, y: 2, hp: 100, attackPower: 20, valor: 20, weight: 55 }),
        new Unit({ name: 'ì˜¤í¬2', team: 'enemy', classType: 'Warrior', x: 13, y: 7, hp: 100, attackPower: 20, valor: 15, weight: 58 }),
        new Unit({ name: 'ê³ ë¸”ë¦° ê¶ìˆ˜1', team: 'enemy', classType: 'Archer',  x: 14, y: 3, hp: 60, attackPower: 25, valor: 10, weight: 32 }),
        new Unit({ name: 'ê³ ë¸”ë¦° ê¶ìˆ˜2', team: 'enemy', classType: 'Archer',  x: 14, y: 6, hp: 60, attackPower: 25, valor: 10, weight: 28 }),
        new Unit({ name: 'ì™€ë¥´ê·¸', team: 'enemy', classType: 'Cavalry', x: 13, y: 5, hp: 80, attackPower: 18, valor: 25, weight: 45 }),
        new Unit({ name: 'í‘ë§ˆë²•ì‚¬', team: 'enemy', classType: 'Mage',    x: 14, y: 5, hp: 50, attackPower: 30, valor: 20, weight: 38 }),
    ];
    allUnits = [...playerUnits, ...enemyUnits];

    logElement.innerHTML = '';
    logMessage('ì „íˆ¬ ì¤€ë¹„ ì™„ë£Œ. ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.');
    flushLog();

    // ë Œë”ë§ ë£¨í”„ ì‹œì‘
    function gameLoop() {
        render(allUnits);
        if (isSimulationRunning) {
            requestAnimationFrame(gameLoop);
        }
    }
    requestAnimationFrame(gameLoop);
}

async function runTurn() {
    logMessage('--- ìƒˆë¡œìš´ í„´ ì‹œì‘ ---');
    
    // [ìµœì í™” 3] ì‚´ì•„ìˆëŠ” ìœ ë‹›ë§Œ í•„í„°ë§í•˜ì—¬ í„´ ìˆœì„œ ê²°ì •
    const turnOrder = allUnits
        .filter(u => !u.isDead)
        .sort((a, b) => a.weight - b.weight);

    turnOrder.forEach(u => u.hasActed = false);

    for (const unit of turnOrder) {
        if (unit.isDead) continue;
        
        // [ìµœì í™” 2] AIì— ì  íŒ€ ì •ë³´ë§Œ ë„˜ê²¨ì£¼ì–´ íƒìƒ‰ ë²”ìœ„ ì¶•ì†Œ
        const enemies = unit.team === 'player' ? enemyUnits.filter(u => !u.isDead) : playerUnits.filter(u => !u.isDead);
        unit.takeTurn(enemies);
        await sleep(300);
    }

    flushLog(); // [ìµœì í™” 4] í„´ì´ ëë‚  ë•Œ ë¡œê·¸ë¥¼ í•œë²ˆì— ì—…ë°ì´íŠ¸

    // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸
    const livingPlayers = playerUnits.filter(u => !u.isDead).length;
    const livingEnemies = enemyUnits.filter(u => !u.isDead).length;

    if (livingPlayers === 0) {
        logMessage('í”Œë ˆì´ì–´ íŒ€ íŒ¨ë°°!');
        isSimulationRunning = false;
        startBtn.disabled = false;
        flushLog();
        return;
    }
    if (livingEnemies === 0) {
        logMessage('í”Œë ˆì´ì–´ íŒ€ ìŠ¹ë¦¬!');
        isSimulationRunning = false;
        startBtn.disabled = false;
        flushLog();
        return;
    }

    if (isSimulationRunning) {
        setTimeout(runTurn, 1000);
    }
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// [ìµœì í™” 4] ë¡œê·¸ ë©”ì‹œì§€ë¥¼ ë²„í¼ì— ì €ì¥
function logMessage(message) {
    logBuffer.push(message);
}

// [ìµœì í™” 4] ë²„í¼ì— ìŒ“ì¸ ë¡œê·¸ë¥¼ í•œë²ˆì— í™”ë©´ì— í‘œì‹œ
function flushLog() {
    if (logBuffer.length > 0) {
        logElement.innerHTML += logBuffer.join('<br>');
        logElement.scrollTop = logElement.scrollHeight;
        logBuffer = [];
    }
}

// ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
startBtn.addEventListener('click', () => {
    if (isSimulationRunning) return;
    
    isSimulationRunning = true;
    startBtn.disabled = true;
    
    init();
    
    // ì‹œë®¬ë ˆì´ì…˜ ë£¨í”„ ì‹œì‘
    runTurn();
});

// í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
window.onload = () => {
    preRenderGrid(); // ë°°ê²½ì„ ë¯¸ë¦¬ ê·¸ë ¤ë‘ 
    init(); // ìœ ë‹› ë“± ë‚˜ë¨¸ì§€ ì´ˆê¸°í™”
    render(allUnits); // ì´ˆê¸° ìƒíƒœ ë Œë”ë§
};
</script>
</body>
</html>
